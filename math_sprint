import streamlit as st
import pandas as pd
import random
import time
import os

# --- Ustawienia ---
DATA_FILE = "ranking.csv"
TIME_LIMIT = 5  # sekundy

# --- Funkcje pomocnicze ---
def generate_problem(level: int):
    max_base = min(10 + int(level * 1.5), 200)
    op = random.choice(["+", "-", "*", "/"])
    a = random.randint(1, max_base)
    b = random.randint(1, max(1, max_base // (4 if op == '*' else 2)))

    if op == "/":
        result = random.randint(1, min(12, int(level / 2 + 3)))
        divisor = b
        dividend = result * divisor
        text = f"{dividend} / {divisor}"
        return text, result
    elif op == "+":
        return f"{a} + {b}", a + b
    elif op == "-":
        return f"{a} - {b}", a - b
    else:
        return f"{a} * {b}", a * b


def load_ranking():
    if not os.path.exists(DATA_FILE) or os.path.getsize(DATA_FILE) == 0:
        return pd.DataFrame(columns=["name", "score"])
    try:
        return pd.read_csv(DATA_FILE)
    except Exception:
        return pd.DataFrame(columns=["name", "score"])


def save_score(name: str, score: int):
    df = load_ranking()
    new_row = pd.DataFrame([[name, score]], columns=["name", "score"])
    df = pd.concat([df, new_row], ignore_index=True)
    df.to_csv(DATA_FILE, index=False)


def build_leaderboard(df: pd.DataFrame):
    if df.empty:
        return pd.DataFrame(columns=["Ucze≈Ñ", "Suma punkt√≥w", "Najlepsza sesja", "Sesje"])
    grouped = df.groupby("name").agg(
        Suma_punkt√≥w=("score", "sum"),
        Najlepsza_sesja=("score", "max"),
        Sesje=("score", "count"),
    ).reset_index().rename(columns={"name": "Ucze≈Ñ"})
    grouped = grouped.sort_values(
        by=["Suma_punkt√≥w", "Najlepsza_sesja"], ascending=False
    ).reset_index(drop=True)
    return grouped


# --- UI ---
st.set_page_config(page_title="Math Sprint", layout="wide")
st.title("üßÆ Math Sprint ‚Äî gra matematyczna")
st.write("Odpowiadaj poprawnie w 5 sekund ‚Äî gra trwa, dop√≥ki nie pope≈Çnisz b≈Çƒôdu.")

col1, col2 = st.columns([2, 1])

with col1:
    name = st.text_input("Twoje imiƒô (widoczne w rankingu)", key="name")

    # Inicjalizacja stanu gry
    if "game_state" not in st.session_state:
        st.session_state.game_state = "ready"  # ready, playing, ended
        st.session_state.level = 1
        st.session_state.score = 0
        st.session_state.problem = None
        st.session_state.answer = None
        st.session_state.start_time = None

    def start_game():
        if not name.strip():
            st.warning("Wpisz imiƒô, aby rozpoczƒÖƒá grƒô!")
            return
        if "," in name:
            st.warning("Nie u≈ºywaj przecink√≥w w imieniu.")
            return
        st.session_state.game_state = "playing"
        st.session_state.level = 1
        st.session_state.score = 0
        problem, ans = generate_problem(1)
        st.session_state.problem = problem
        st.session_state.answer = ans
        st.session_state.start_time = time.time()

    def end_game():
        st.session_state.game_state = "ended"
        if name.strip():
            save_score(name.strip(), st.session_state.score)

    # --- Logika gry ---
    if st.session_state.game_state == "ready":
        if st.button("‚ñ∂Ô∏è Start gry"):
            start_game()

    elif st.session_state.game_state == "playing":
        elapsed = time.time() - st.session_state.start_time
        remaining = TIME_LIMIT - elapsed

        if remaining <= 0:
            st.error(f"‚è∞ Czas minƒÖ≈Ç! Tw√≥j wynik: {st.session_state.score} pkt.")
            end_game()
        else:
            st.metric("Pozosta≈Çy czas", f"{remaining:.1f}s")
            st.subheader(f"Zadanie: {st.session_state.problem}")
            user_input = st.text_input("Wpisz odpowied≈∫ i naci≈õnij Enter:", key="answer_input")
            if user_input:
                try:
                    val = float(user_input)
                    if abs(val - st.session_state.answer) < 1e-6:
                        st.success("‚úÖ Poprawna odpowied≈∫!")
                        st.session_state.score += max(1, st.session_state.level // 2 + 1)
                        st.session_state.level += 1
                        problem, ans = generate_problem(st.session_state.level)
                        st.session_state.problem = problem
                        st.session_state.answer = ans
                        st.session_state.start_time = time.time()
                        st.rerun()
                    else:
                        st.error(f"‚ùå B≈Çƒôdna odpowied≈∫! Tw√≥j wynik: {st.session_state.score} pkt.")
                        end_game()
                except ValueError:
                    st.warning("Podaj liczbƒô.")

        st.write(f"**Poziom:** {st.session_state.level} | **Wynik:** {st.session_state.score}")
        if st.button("üè≥Ô∏è Poddaj siƒô"):
            st.warning(f"Koniec gry! Tw√≥j wynik: {st.session_state.score} pkt.")
            end_game()

    elif st.session_state.game_state == "ended":
        st.success(f"Koniec gry! Tw√≥j wynik: {st.session_state.score} pkt.")
        if st.button("üîÅ Zagraj ponownie"):
            st.session_state.game_state = "ready"
            st.rerun()

with col2:
    st.subheader("üèÜ Ranking publiczny")
    df = load_ranking()
    leaderboard = build_leaderboard(df)
    st.dataframe(leaderboard, use_container_width=True)
    st.caption("Ranking pokazuje sumƒô punkt√≥w oraz najlepszy wynik ka≈ºdej osoby.")
